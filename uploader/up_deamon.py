import os, time
import logging
from . import up_tasks
from typing import Dict, Any
#
# from environs import Env
#
# env = Env()
# env.read_env()

_base_dir = os.path.dirname(os.path.abspath(__file__))
_deamon_path = os.path.join(_base_dir, "up_deamon")
_touch = "touched"


def set_deamon_logger(args: Dict) -> Dict:
    """Setting logger
    NOTE: this loger is pointing to a log file (this is a deamon!)

    Args:
        args (Dict): cli arguments

    Returns:
        logger (Any): logging object
    """
    log_level = logging.INFO
    if args.verbosity:
        log_level = logging.DEBUG

    logger = logging.getLogger(__name__)
    logger.setLevel(log_level)

    fh = logging.FileHandler(args.logfile)
    fh.setLevel(log_level)
    logger.addHandler(fh)

    return logger


def untouched(path: str) -> bool:
    """
    returns true if a file has not been "touched"

    Args:
        path (str): path to be verified

    Returns:
        bool
    """
    return not _touch in path


def touch_file(path: str) -> None:
    """
    flag a file or directory as "touched"

    Args:
        path (str): name of the object to be "touched"

    """
    logger = logging.getLogger(__name__)
    try:
        os.rename(path, f"{path}-{_touch}")
    except IOError as error:
        logger.error(f"Path {path} renamed error\n{error}")
        raise


def upload_task(
    data_path: str, filename: str, args: Dict, logger: Any
) -> str:
    """
    triggers luigi upload task. Returns status from luigi task

    Args:
        data_path (str): path where data resides
        filename (str): file to be processed
        args (Dict): cli arguments
        logger (Any): logger object

    Returns:
        str
    """
    input_path = os.path.join(data_path, filename)

    # catches hidden files within data_path
    if filename.startswith("."):
        return "HiddenFile"

    # trigger luigi task
    # Important: we need to have "detailed_summary=True"
    #            to get the right status object.
    status = up_tasks.push_files(input_path=input_path, batch_id=filename, args=args)

    # Luigi return status (inside dict)
    status_flag = status.status.__dict__["_name_"]

    logger.debug("\n\n>>>>>>>> LOAD TASK START <<<<<<<<<")
    logger.debug(f"\n\n>>> Trying to upload {input_path}")
    logger.debug(status.__dict__["summary_text"])

    if status_flag == "SUCCESS":
        touch_file(input_path)

    return status_flag


def scan_dirs(args: Dict, logger: Any) -> None:
    """
    scan for data generated by the sensor and
    upload it

    Args:
        args (Dict): cli arguments
        logger (Any): logger object

    """
    path = args.data_path

    [upload_task(path, f, args, logger) for f in os.listdir(path) if untouched(f)]


def worker(args: Dict) -> None:
    """
    Keeps daemon scanning until break signal is send; review file.pid to get daemon PID

    Args:
        args (Dict): cli arguments
    """
    # starts sleepy so I can look for temp files
    sleep_time = int(os.environ["DAEMON_CYCLE"])
    logger = set_deamon_logger(args)

    while True:
        scan_dirs(args, logger)
        time.sleep(sleep_time)
